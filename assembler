#!/usr/bin/env python3
#
# Copyright 2020 Christian Seberino
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import string
import sys

FUNCS     = ["add", "sub", "and", "or",
                     "zjump", "gjump", "copy", "read", "write", "stop"]
NAT_SIZE  = 3
NIBB_SIZE = 0.5
WORD_SIZE = 4

def get_hex(orig, size):
        return hex(int(orig))[2:].zfill(int(2 * size))

def get_natural(orig, size):
        if   orig.startswith("0x"):
                natural = orig[2:].zfill(2 * size)
        elif orig[0] in string.ascii_letters:
                natural = get_hex(aliases[orig], size)
        else:
                natural = get_hex(orig, size)

        return natural

code    = ""
words   = [e.strip() for e in open(sys.argv[1]).readlines()]
words   = [e for e in words if e and not e.startswith("#")]
aliases = [(e.split()[0], 4 * i) for i, e in enumerate(words)]
aliases = dict([(e[0][:-1], e[1]) for e in aliases if e[0].endswith(":")])
for e in words:
        e = e.split()[1:] if e.split()[0].endswith(":") else e.split()
        if e[0] in FUNCS:
                code_  = get_hex(FUNCS.index(e[0]), NIBB_SIZE)
                if e[0] == "copy":
                        code_ += get_natural(e[1], NAT_SIZE)
                        code_ += get_hex(e[2][1:], NIBB_SIZE)
                else:
                        for reg in e[1:]:
                                code_ += get_hex(reg[1:], NIBB_SIZE)
                code  += code_.ljust(2 * WORD_SIZE, "0")
        else:
                code  += get_natural(e[0], WORD_SIZE)
open(sys.argv[1] + ".mem", "wb").write(bytes.fromhex(code))
